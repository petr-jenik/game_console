#include "my_user_input.h"
#include <cstring>

#ifdef BUILD_FOR_X86
#include <ArduinoApi.h>
#else
#include <Arduino.h>
#endif //BUILD_FOR_X86

/*
  eKey_FIRST = 0,
  eKey_Up = eKey_FIRST,
  eKey_Down = 1,
  eKey_Left = 2,
  eKey_Right = 3,
  eKey_Enter = 4,
  eKey_Back = 5,
  eKey_LAST = eKey_Back,
  eKey_COUNT
*/

// Enter = D12
// B = D14
// Down = D13
// Right = D27
// Up = D25
// Left = D33 // TODO
static bool gKeyStates[UserInput::Keys::eKey_COUNT] = {0};
const int buttonPins[] = {25, 13, 33, 27, 12, 14};

static_assert(sizeof(gKeyStates) / sizeof(gKeyStates[0]) == sizeof(buttonPins) / sizeof(buttonPins[0]), "Invalid number of GPIO pins defined");

void UserInput::init()
{
    for (int iButton = 0; iButton < sizeof(buttonPins) / sizeof(buttonPins[0]); iButton++)
    {
        pinMode(buttonPins[iButton], INPUT_PULLUP);
    }
}

#ifndef BUILD_FOR_X86


bool UserInput::isKeyPressed(UserInput::Keys eKey)
{
    bool retval = false;
    if ((eKey >= eKey_FIRST) && (eKey <= eKey_LAST))
    {
        // Input buttons use pullups and connect line to the ground. Therefore value has to be inverted.
        retval = ! digitalRead(buttonPins[eKey]);
    }
    return retval;
}

#else
bool UserInput::isKeyPressed(UserInput::Keys eKey)
{
    bool retval = false;
    if ((eKey >= eKey_FIRST) && (eKey <= eKey_LAST)){
        retval = gKeyStates[eKey];
    }
    return retval;
}

void UserInput::processKeyStates(const char * rxMessage)
{
    if (strlen(rxMessage) != (UserInput::eKey_COUNT))
    {
    //std::cout << "Invalid state of keys received" << std::endl;
    return;
    }

    bool retval = false;
    for (int keyIndex = static_cast<int>(UserInput::eKey_FIRST); keyIndex <= static_cast<int>(UserInput::eKey_LAST); keyIndex++)
    {
        char c = rxMessage[keyIndex];

        if ((c != '0') && (c != '1'))
        {
            //std::cout << "Invalid state of keys received" << std::endl;
            return;
        }

        gKeyStates[keyIndex] = (c == '1');
    }
}
    #endif //BUILD_FOR_X86
